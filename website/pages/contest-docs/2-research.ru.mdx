import Image from "next/image"

# Исследование предметной области. Изображения и средства их просмотра.

## Определение изображения

**Изображение** - предмет, рисунок и т. п., изображающий кого-либо или что-либо; зрительное воспроизведение некоторого объекта.
Далее будут рассмотрены и сравнены два вида изображений: **оптическое** и **цифровое**.

### Оптическое изображение

**Оптическое изображение** - это изображение, получаемое при помощи оптической системы (линзы, зеркала, фотоаппарата).
Оптическая система фокусирует свет от объекта на светочувствительном элементе (фотопленке, матрице),
формируя копию оптического представления объекта – изображение.
Главным достоинством оптических изображений является высокое качество и практически полное отсутствие
потерь при съёмке. Однако это зависит от используемой оптической системы, наличия достаточного освещения и т. д.
Также оптические изображения требуют некоторого физического носителя для хранения (и обработки).

### Цифровое изображение и способы его представления

**Цифровое изображение** - представление некоторого оптического изображения
в цифровом формате - наборе чисел, описывающих цвета и яркость отдельных точек изображения.

В зависимости от способа описания, цифровое изображение может быть представлено в виде *растровом* или *векторном* формате.

**Растровое изображение** - это изображение, представленное в виде двумерного массива чисел (матрицы),
где каждый элемент соответствует одному пикселю. Растровое изображение возможно получить
как с помощью съёмки оптической системой (или оптического сканирования), так и с помощью
средств машинной графики. Растровые изображения могут храниться в различных форматах, которые отличаются способом
хранения информации о пикселях, наличием информации об изображении (метаданных) и возможностью сжатия,
поскольку результирующий массив может иметь огромный размер.
Стоит подметить, что любое растровое изображение ограничено конкретным разрешением - количеством пикселей
по вертикали и горизонтали. Иными словами, разрешение - это размерность массива (матрицы) с информацией о пикселях.
Увеличение разрешения, а следовательно, и длины массива пикселей, позволяет передать изображение объекта
в более точной и детализированной форме, но это также влечёт за собой увеличение размера цифрового изображения.

Примеры форматов растрового изображения:
* PNG (Portable Network Graphics)
* JPEG (Joint Photographic Experts Group)
* GIF (Graphics Interchange Format)
* BMP (Bitmap, Windows Bitmap)
* TIFF (Tagged Image File Format)
* WebP (Web Picture, иногда Google's Web Picture)
* Raw (нестандартизированный формат "сырых" изображений с матрицы фотоаппарата)

<Image
src="https://cdn.discordapp.com/attachments/784756501612986409/1210631687567052881/smupe_icon.webp?ex=65eb439e&is=65d8ce9e&hm=164ba906f2523b06e40b166328583299369ff269d8a41dbfd62a3d32f2260dcd&"
alt="Логотип приложения в растровом формате"
width={256}
height={256} />

> Представление логотипа этого приложения в растровом формате WebP (Google's Web Picture).
Разрешение намеренно сокращено для подчёркивания особенности "растрового" представления.

**Векторное изображение** - это изображение, представленное в виде описаний простейших геометрических элементов,
таких как точки, кривые, круги и окружности, многоугольники. В отличие от растрового, векторное изображение может
быть получено только с помощью машинной графики. Однако, векторное изображение не имеет ограничений по
разрешению как таковых, а следовательно, может масштабироваться без потерь до бесконечности.
Представление в виде геометрических элементов делает создание сложных объектов очень трудной и нерациональной задачей.

Примеры векторных форматов изображений:
* SVG (Scalable Vector Graphics)
* PDF (Portable Document Format)
* AI (Adobe Illustrator Document)
* FLA (Adobe Flash Animation)
* SWF (Small Web Format, ранее Shockwave Flash)
* TTF, OTF, WOFF (TrueType, OpenType, Web Open Font Format - форматы шрифтов)

![Логотип приложения в векторном формате](/smupe_icon.svg)
> Логотип этого приложения выполнен в векторном формате SVG (Scalable Vector Graphics).

## Просмотр цифровых изображений

Когда мы говорим о просмотре оптического изображения, мы обычно имеем в виду
просмотр картин и фотографий. Оптическое изображение уже представлено в "читаемой" форме.
Однако, с цифровым изображением не всё так просто. Человек не сможет прочесть массив
чисел или геометрическое описание, чтобы у него в голове появилось какое-то цветное изображение.
Для работы с цифровыми изображениями используются **программы для просмотра изображений**.

Основными функциями данных приложений являются:
* предоставление списка изображений на устройстве
* просмотр (отрисовка) изображений, как для отдельных, так и для групп (в виде ленты-карусели, слайд-шоу, и т. д.)
* минимальные функции редактирования изображений
* управление файлами изображений (просмотр и редактирование метаданных, переименование и удаление файлов)
* список избранных и недавно удалённых изображений
* опционально поддержка внешних источников изображений (напр. в Google Фото есть возможность просмотра Google Диска)

Примеры программ для просмотра:
* На Windows:
    * Просмотр фотографий Windows (Фотографии)
    * Google Фото (Picasa)
    * ACDSee
    * FastStone Image Viewer
    * ФотоМастер
    * XnView
* На смартфонах:
    * "Галерея"
    * Google Фото
    * и др.


Данные приложения выполняют чтение файла изображения и отображают его на экране.
Для этого используются специальные алгоритмы конкретных форматов.

В общем виде данный алгоритм выглядит так:

<details>

<summary>Алгоритм чтения и отрисовки изображения (нажмите для открытия).</summary>

> Приведены примеры на алгоритмическом псевдоязыке и языке Kotlin

1. Открытие файла изображения и чтение его содержимого в массив байт/символов
    ```
    МассивИзображение Типа Массив[Байты] = ПрочитатьФайл(ИмяФайла);
    ```
    ```kt
    val imageBytes: List<Byte> = Files.readAllBytes(Paths.get(imagePath))
    ```
2. Определение типа (формата) изображения по сигнатуре ("магическим числам")
    и/или расширению/MIME-типу. Это позволяет выбрать подходящие алгоритмы
    десериализации и декомпрессии.
    ```
    Сигнатура Типа Массив[Байты] = СрезМассива(МассивИзображения, 4);
    Формат Типа Перечисление[Форматы] = ОпределитьФорматПоСигнатуре(Сигнатура);
    АлгоритмОтрисовки Типа Процедура = ВыбратьАлгоритмОтрисовки(Формат);
    ```
    ```kt
    val signature: List<Byte> = imageBytes.subList(0, 4)
    val format: ImageFormat = when (signature) {
        listOf(0x89, 0x50, 0x4E, 0x47) -> { ImageFormat.PNG },
        listOf(0xFF, 0xD8, 0xFF, 0xE0) -> { ImageFormat.JPEG },
        listOf(0x00, 0x01, 0x02, 0x03) -> { ImageFormat.RAW }
    }
    val rendererAlgorithms: List<(List<Byte>) -> Unit> = listOf(renderPng, renderJpeg, renderRaw)
    val rendererAlgorithm: (List<Byte>) -> Unit = rendererAlgorithms[format.ordinal]
    ```
3. Запуск выбранного алгоритма
    ```
    ЗапускПотока(АлгоритмОтрисовки, МассивИзображения);
    ```
    ```kt
    thread(start = true) {
        rendererAlgorithm(imageBytes)
    }
4. Разбивка массива байт/символов на куски, с которыми далее будет работать алгоритм
    ```
    // В процедуре АлгоритмОтрисовки
    Процедура АлгоритмОтрисовки(ВходнойМассив Типа Массив[Байты])
      МассивКусков Типа Массив[Массив[Байты, 1024 элемента]] = РазбитьМассив(ВходнойМассив, 1024);
    ```
    ```kt
    fun renderRaw(imageBytes: List<Byte>) {
        val imageChunks: List<List<Byte>> = imageBytes.chunked(1024)
        // ...
    }
    ```
5. Итерирование по куску данных
    ```
    // В процедуре АлгоритмОтрисовки
    ДляКаждого Кусок В МассивКусков Сделать
      // действия с куском
    Далее
    ```
    ```kt
    // ...
    imageChunks.forEach { chunk ->
        // действия с куском
    }
    ```
6. Десериализация и декомпрессия куска в объекты пикселей формата "номер пикселя, цвет в RGBA"
    ```
    // В цикле по кускам
    Пиксель Типа Кортеж[Целое, Целое, Целое, Целое] = Декомпрессия(Кусок);
    ```
    ```kt
    // ...
    val pixel: (Byte, Byte, Byte, Byte) = decompress(chunk)
    ```
7. Конвертация пикселей в данные для вершинных и фрагментных шейдеров
    ```
    // В цикле по кускам
    Буфер Типа БуферВершин = СоздатьБуферВершин();
    ПривязкаВершин(Буфер, Пиксель);
    ВычислитьВершины(Буфер);
    Фрагмент Типа Фрагмент = СоздатьФрагментныйШейдер(Буфер);
    ВычислитьФрагмент(Фрагмент);
    ```
    ```kt
    val vba: VertexBuffer = GL.createVertexBuffer()
    vba.bind(pixel)
    vba.compute()
    val fs: FragmentShader = GL.createFragmentShader(rawFragShaderSrc)
    fs.compute(vba)
    ```
8. Отрисовка изображения на основе шейдеров
    ```
    // В процедуре АлгоритмОтрисовки
    ОтрисоватьОчередьФрагментов();
    ```
    ```kt
    GL.runInLoop {
        this.swapBuffers()
        this.draw()
    }
    ```

</details>